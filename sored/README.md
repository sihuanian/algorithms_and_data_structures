##　对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数 、低阶（数据规模小）
3. 比较次数和交换（或移动）次数

- `原地排序`（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。
- 稳定性: 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，即相同的两个数据相对位置不会发生互换
- 有序度是数组中具有有序关系的元素对的个数。
  > 有序元素对：a[i] <= a[j], 如果 i < j。
  > 逆序元素对：a[i] > a[j], 如果 i < j。
  > 满有序度： n(n - 1) / 2
  > 满有序度 = 有序度 + 逆序度


### 冒泡排序
- 双重循环，每次都将最大值放到后面
1. 双重循环 for(let i = 0;i < arr.length - 1;i++)
2. 第二重循环 for (let j = 0;j < arr.length - 1 - i; j++)
  为什么是： j < arr.length - 1 - i
  第一次执行这个循环是找到的是最大值
  第一次执行这个循环是找到的是第二大的值
  .
  .
  .

tips: 设定一个判断是否有数据移到的开头变量，当没有数据移动时就是循环退出的时候，可以减少一些执行时间。



### 插入排序

- 我们将数组中的数据分为两个区间，**已排序区间和未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。


### 选择排序

![选择排序原理图](./img/选择排序原理图.jpg)

### 冒泡、插入、选择排序总结 

![冒泡排序、插入排序、选择排序](./img/冒泡、插入、选择排序.jpg)
